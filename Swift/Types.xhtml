<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
  	<link href="epub.css" media="all" rel="stylesheet" type="text/css" />
  	<script type="text/javascript" src="svg.js"></script>
  </head>
  <body id="conceptual_flow_with_tasks">
    <div class="content-wrapper">
      <div id="chapter_container" class='conceptualwithtasks'>
  <article class="chapter">
    <a id="TP40016643-CH31">&#x200c;</a><a id="TP40016643-CH31-ID445">&#x200c;</a>
    <h2 class="chapter-name">Types</h2>
      
      	<section class="section">
      		<p class="para">In Swift, there are two kinds of types: named types and compound types. A <em>named type</em> is a type that can be given a particular name when it is defined. Named types include classes, structures, enumerations, and protocols. For example, instances of a user-defined class named <code class="code-voice">MyClass</code> have the type <code class="code-voice">MyClass</code>. In addition to user-defined named types, the Swift standard library defines many commonly used named types, including those that represent arrays, dictionaries, and optional values.</p><p class="para">Data types that are normally considered basic or primitive in other languages—such as types that represent numbers, characters, and strings—are actually named types, defined and implemented in the Swift standard library using structures. Because they are named types, you can extend their behavior to suit the needs of your program, using an extension declaration, discussed in <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH24-ID151" href="Extensions.xhtml">Extensions</a> and <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH34-ID378" href="Declarations.xhtml#TP40016643-CH34-ID378">Extension Declaration</a>.</p><p class="para">A <em>compound type</em> is a type without a name, defined in the Swift language itself. There are two compound types: function types and tuple types. A compound type may contain named types and other compound types. For instance, the tuple type <code class="code-voice">(Int, (Int, Int))</code> contains two elements: The first is the named type <code class="code-voice">Int</code>, and the second is another compound type <code class="code-voice">(Int, Int)</code>.</p><p class="para">This chapter discusses the types defined in the Swift language itself and describes the type inference behavior of Swift.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="type">&#x200c;</a>
  <span class="syntax-def-name">
  type
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/array-type" href="Types.xhtml#array-type">array-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/dictionary-type" href="Types.xhtml#dictionary-type">dictionary-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/function-type" href="Types.xhtml#function-type">function-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-identifier" href="Types.xhtml#type-identifier">type-identifier</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type" href="Types.xhtml#tuple-type">tuple-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/optional-type" href="Types.xhtml#optional-type">optional-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/implicitly-unwrapped-optional-type" href="Types.xhtml#implicitly-unwrapped-optional-type">implicitly-unwrapped-optional-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/protocol-composition-type" href="Types.xhtml#protocol-composition-type">protocol-composition-type</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/metatype-type" href="Types.xhtml#metatype-type">metatype-type</a></span>
</span>
</p>
</div>
 </div>
    		</section> 


      <section class="section">
	<a id="TP40016643-CH31-ID446">&#x200c;</a>
  <h3 class="section-name">Type Annotation</h3>
  <p class="para">A <em>type annotation</em> explicitly specifies the type of a variable or expression. Type annotations begin with a colon (<code class="code-voice">:</code>) and end with a type, as the following examples show:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someTuple</code>: (<code class="n"><!-- a href="" logicalPath="" -->Double<!-- /a --></code>, <code class="n"><!-- a href="" logicalPath="" -->Double<!-- /a --></code>) = (<code class="m">3.14159</code>, <code class="m">2.71828</code>)</code></li>
            <li><code class="code-voice"><code class="kt">func</code> <code class="vc">someFunction</code>(<code class="vc">a</code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>) { <code class="c">/* ... */</code> }</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In the first example, the expression <code class="code-voice">someTuple</code> is specified to have the tuple type <code class="code-voice">(Double, Double)</code>. In the second example, the parameter <code class="code-voice">a</code> to the function <code class="code-voice">someFunction</code> is specified to have the type <code class="code-voice">Int</code>.</p><p class="para">Type annotations can contain an optional list of type attributes before the type.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a type annotation
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="type-annotation">&#x200c;</a>
  <span class="syntax-def-name">
  type-annotation
</span>
<span class="arrow">
  →
</span><code class="literal">:</code><span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/attributes" href="Attributes.xhtml#attributes">attributes</a></span><sub class="subscript">opt</sub></span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID447">&#x200c;</a>
  <h3 class="section-name">Type Identifier</h3>
  <p class="para">A type identifier refers to either a named type or a type alias of a named or compound type.</p><p class="para">Most of the time, a type identifier directly refers to a named type with the same name as the identifier. For example, <code class="code-voice">Int</code> is a type identifier that directly refers to the named type <code class="code-voice">Int</code>, and the type identifier <code class="code-voice">Dictionary&lt;String, Int&gt;</code> directly refers to the named type <code class="code-voice">Dictionary&lt;String, Int&gt;</code>.</p><p class="para">There are two cases in which a type identifier does not refer to a type with the same name. In the first case, a type identifier refers to a type alias of a named or compound type. For instance, in the example below, the use of <code class="code-voice">Point</code> in the type annotation refers to the tuple type <code class="code-voice">(Int, Int)</code>.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">typealias</code> <code class="vc">Point</code> = (<code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>, <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>)</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">origin</code>: <code class="n"><!-- a href="" logicalPath="" -->Point<!-- /a --></code> = (<code class="m">0</code>, <code class="m">0</code>)</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In the second case, a type identifier uses dot (<code class="code-voice">.</code>) syntax to refer to named types declared in other modules or nested within other types. For example, the type identifier in the following code references the named type <code class="code-voice">MyType</code> that is declared in the <code class="code-voice">ExampleModule</code> module.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">someValue</code>: <code class="n"><!-- a href="" logicalPath="" -->ExampleModule<!-- /a --></code>.<code class="n"><!-- a href="" logicalPath="" -->MyType<!-- /a --></code></code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a type identifier
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="type-identifier">&#x200c;</a>
  <span class="syntax-def-name">
  type-identifier
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-name" href="Types.xhtml#type-name">type-name</a></span><span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/generic-argument-clause" href="GenericParametersAndArguments.xhtml#generic-argument-clause">generic-argument-clause</a></span><sub class="subscript">opt</sub></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-name" href="Types.xhtml#type-name">type-name</a></span><span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/generic-argument-clause" href="GenericParametersAndArguments.xhtml#generic-argument-clause">generic-argument-clause</a></span><sub class="subscript">opt</sub></span><code class="literal">.</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-identifier" href="Types.xhtml#type-identifier">type-identifier</a></span>
</span>
</p><p class="syntax-def">
  <a id="type-name">&#x200c;</a>
  <span class="syntax-def-name">
  type-name
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/identifier" href="LexicalStructure.xhtml#identifier">identifier</a></span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID448">&#x200c;</a>
  <h3 class="section-name">Tuple Type</h3>
  <p class="para">A tuple type is a comma-separated list of zero or more types, enclosed in parentheses.</p><p class="para">You can use a tuple type as the return type of a function to enable the function to return a single tuple containing multiple values. You can also name the elements of a tuple type and use those names to refer to the values of the individual elements. An element name consists of an identifier followed immediately by a colon (:). For an example that demonstrates both of these features, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH10-ID164" href="Functions.xhtml#TP40016643-CH10-ID164">Functions with Multiple Return Values</a>.</p><p class="para"><code class="code-voice">Void</code> is a type alias for the empty tuple type, <code class="code-voice">()</code>. If there is only one element inside the parentheses, the type is simply the type of that element. For example, the type of <code class="code-voice">(Int)</code> is <code class="code-voice">Int</code>, not <code class="code-voice">(Int)</code>. As a result, you can name a tuple element only when the tuple type has two or more elements.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a tuple type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="tuple-type">&#x200c;</a>
  <span class="syntax-def-name">
  tuple-type
</span>
<span class="arrow">
  →
</span><code class="literal">(</code><span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type-body" href="Types.xhtml#tuple-type-body">tuple-type-body</a></span><sub class="subscript">opt</sub></span><code class="literal">)</code>
</p><p class="syntax-def">
  <a id="tuple-type-body">&#x200c;</a>
  <span class="syntax-def-name">
  tuple-type-body
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type-element-list" href="Types.xhtml#tuple-type-element-list">tuple-type-element-list</a></span><span class="optional"><code class="literal">...</code><sub class="subscript">opt</sub></span>
</p><p class="syntax-def">
  <a id="tuple-type-element-list">&#x200c;</a>
  <span class="syntax-def-name">
  tuple-type-element-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type-element" href="Types.xhtml#tuple-type-element">tuple-type-element</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type-element" href="Types.xhtml#tuple-type-element">tuple-type-element</a></span><code class="literal">,</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/tuple-type-element-list" href="Types.xhtml#tuple-type-element-list">tuple-type-element-list</a></span>
</span>
</p><p class="syntax-def">
  <a id="tuple-type-element">&#x200c;</a>
  <span class="syntax-def-name">
  tuple-type-element
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/attributes" href="Attributes.xhtml#attributes">attributes</a></span><sub class="subscript">opt</sub></span><span class="optional"><code class="literal">inout</code><sub class="subscript">opt</sub></span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span>
</span><span class="alternative">
  <span class="optional"><code class="literal">inout</code><sub class="subscript">opt</sub></span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/element-name" href="Types.xhtml#element-name">element-name</a></span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-annotation" href="Types.xhtml#type-annotation">type-annotation</a></span>
</span>
</p><p class="syntax-def">
  <a id="element-name">&#x200c;</a>
  <span class="syntax-def-name">
  element-name
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/identifier" href="LexicalStructure.xhtml#identifier">identifier</a></span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID449">&#x200c;</a>
  <h3 class="section-name">Function Type</h3>
  <p class="para">A function type represents the type of a function, method, or closure and consists of a parameter and return type separated by an arrow (<code class="code-voice">-&gt;</code>):</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines code-voice">
    <li><pre class="code-voice"><em class="variable-text">parameter type</em> -&gt; <em class="variable-text">return type</em></pre></li>
  </ul>
</div><p class="para">Because the <em>parameter type</em> and the <em>return type</em> can be a tuple type, function types support functions and methods that take multiple parameters and return multiple values.</p><p class="para">A parameter of the function type <code class="code-voice">() -&gt; T</code> (where <code class="code-voice">T</code> is any type) can apply the <code class="code-voice">autoclosure</code> attribute to implicitly create a closure at its call sites. This provides a syntactically convenient way to defer the evaluation of an expression without needing to write an explicit closure when you call the function. For an example of an autoclosure function type parameter, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH11-ID543" href="Closures.xhtml#TP40016643-CH11-ID543">Autoclosures</a>.</p><p class="para">A function type can have a variadic parameter in its <em>parameter type</em>. Syntactically, a variadic parameter consists of a base type name followed immediately by three dots (<code class="code-voice">...</code>), as in <code class="code-voice">Int...</code>. A variadic parameter is treated as an array that contains elements of the base type name. For instance, the variadic parameter <code class="code-voice">Int...</code> is treated as <code class="code-voice">[Int]</code>. For an example that uses a variadic parameter, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH10-ID171" href="Functions.xhtml#TP40016643-CH10-ID171">Variadic Parameters</a>.</p><p class="para">To specify an in-out parameter, prefix the parameter type with the <code class="code-voice">inout</code> keyword. You can’t mark a variadic parameter or a return type with the <code class="code-voice">inout</code> keyword. In-out parameters are discussed in <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH10-ID173" href="Functions.xhtml#TP40016643-CH10-ID173">In-Out Parameters</a>.</p><p class="para">If a function type includes more than a single arrow (<code class="code-voice">-&gt;</code>), the function types are grouped from right to left. For example, the function type <code class="code-voice">Int -&gt; Int -&gt; Int</code> is understood as <code class="code-voice">Int -&gt; (Int -&gt; Int)</code>—that is, a function that takes an <code class="code-voice">Int</code> and returns another function that takes and returns an <code class="code-voice">Int</code>.</p><p class="para">Function types that can throw an error must be marked with the <code class="code-voice">throws</code> keyword, and function types that can rethrow an error must be marked with the <code class="code-voice">rethrows</code> keyword. The <code class="code-voice">throws</code> keyword is part of a function’s type, and nonthrowing functions are subtypes of throwing functions. As a result, you can use a nonthrowing function in the same places as a throwing one. Throwing and rethrowing functions are described in <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH34-ID530" href="Declarations.xhtml#TP40016643-CH34-ID530">Throwing Functions and Methods</a> and <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH34-ID531" href="Declarations.xhtml#TP40016643-CH34-ID531">Rethrowing Functions and Methods</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a function type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="function-type">&#x200c;</a>
  <span class="syntax-def-name">
  function-type
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><span class="optional"><code class="literal">throws</code><sub class="subscript">opt</sub></span><code class="literal">-&gt;</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span>
</p><p class="syntax-def">
  <a id="TP40016643-CH31-NoLink_347">&#x200c;</a>
  <span class="syntax-def-name">
  function-type
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">rethrows</code><code class="literal">-&gt;</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID450">&#x200c;</a>
  <h3 class="section-name">Array Type</h3>
  <p class="para">The Swift language provides the following syntactic sugar for the Swift standard library <code class="code-voice">Array&lt;Element&gt;</code> type:</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines code-voice">
    <li><pre class="code-voice">[<em class="variable-text">type</em>]</pre></li>
  </ul>
</div><p class="para">In other words, the following two declarations are equivalent:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someArray</code>: <code class="n"><!-- a href="" logicalPath="" -->Array<!-- /a --></code>&lt;<code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>&gt; = [<code class="s">&quot;Alex&quot;</code>, <code class="s">&quot;Brian&quot;</code>, <code class="s">&quot;Dave&quot;</code>]</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someArray</code>: [<code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>] = [<code class="s">&quot;Alex&quot;</code>, <code class="s">&quot;Brian&quot;</code>, <code class="s">&quot;Dave&quot;</code>]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In both cases, the constant <code class="code-voice">someArray</code> is declared as an array of strings. The elements of an array can be accessed through subscripting by specifying a valid index value in square brackets: <code class="code-voice">someArray[0]</code> refers to the element at index 0, <code class="code-voice">&quot;Alex&quot;</code>.</p><p class="para">You can create multidimensional arrays by nesting pairs of square brackets, where the name of the base type of the elements is contained in the innermost pair of square brackets. For example, you can create a three-dimensional array of integers using three sets of square brackets:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">array3D</code>: [[[<code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>]]] = [[[<code class="m">1</code>, <code class="m">2</code>], [<code class="m">3</code>, <code class="m">4</code>]], [[<code class="m">5</code>, <code class="m">6</code>], [<code class="m">7</code>, <code class="m">8</code>]]]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">When accessing the elements in a multidimensional array, the left-most subscript index refers to the element at that index in the outermost array. The next subscript index to the right refers to the element at that index in the array that’s nested one level in. And so on. This means that in the example above, <code class="code-voice">array3D[0]</code> refers to <code class="code-voice">[[1, 2], [3, 4]]</code>, <code class="code-voice">array3D[0][1]</code> refers to <code class="code-voice">[3, 4]</code>, and <code class="code-voice">array3D[0][1][1]</code> refers to the value 4.</p><p class="para">For a detailed discussion of the Swift standard library <code class="code-voice">Array</code> type, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH8-ID107" href="CollectionTypes.xhtml#TP40016643-CH8-ID107">Arrays</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an array type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="array-type">&#x200c;</a>
  <span class="syntax-def-name">
  array-type
</span>
<span class="arrow">
  →
</span><code class="literal">[</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">]</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID451">&#x200c;</a>
  <h3 class="section-name">Dictionary Type</h3>
  <p class="para">The Swift language provides the following syntactic sugar for the Swift standard library <code class="code-voice">Dictionary&lt;Key, Value&gt;</code> type:</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines code-voice">
    <li><pre class="code-voice">[<em class="variable-text">key type</em>: <em class="variable-text">value type</em>]</pre></li>
  </ul>
</div><p class="para">In other words, the following two declarations are equivalent:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someDictionary</code>: [<code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>] = [<code class="s">&quot;Alex&quot;</code>: <code class="m">31</code>, <code class="s">&quot;Paul&quot;</code>: <code class="m">39</code>]</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someDictionary</code>: <code class="n"><!-- a href="" logicalPath="" -->Dictionary<!-- /a --></code>&lt;<code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>, <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>&gt; = [<code class="s">&quot;Alex&quot;</code>: <code class="m">31</code>, <code class="s">&quot;Paul&quot;</code>: <code class="m">39</code>]</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In both cases, the constant <code class="code-voice">someDictionary</code> is declared as a dictionary with strings as keys and integers as values.</p><p class="para">The values of a dictionary can be accessed through subscripting by specifying the corresponding key in square brackets: <code class="code-voice">someDictionary[&quot;Alex&quot;]</code> refers to the value associated with the key <code class="code-voice">&quot;Alex&quot;</code>. The subscript returns an optional value of the dictionary’s value type. If the specified key isn’t contained in the dictionary, the subscript returns <code class="code-voice">nil</code>.</p><p class="para">The key type of a dictionary must conform to the Swift standard library <code class="code-voice">Hashable</code> protocol.</p><p class="para">For a detailed discussion of the Swift standard library <code class="code-voice">Dictionary</code> type, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH8-ID113" href="CollectionTypes.xhtml#TP40016643-CH8-ID113">Dictionaries</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a dictionary type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="dictionary-type">&#x200c;</a>
  <span class="syntax-def-name">
  dictionary-type
</span>
<span class="arrow">
  →
</span><code class="literal">[</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">:</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">]</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID452">&#x200c;</a>
  <h3 class="section-name">Optional Type</h3>
  <p class="para">The Swift language defines the postfix <code class="code-voice">?</code> as syntactic sugar for the named type <code class="code-voice">Optional&lt;Wrapped&gt;</code>, which is defined in the Swift standard library. In other words, the following two declarations are equivalent:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">optionalInteger</code>: <code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>?</code></li>
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">optionalInteger</code>: <code class="n"><!-- a href="" logicalPath="" -->Optional<!-- /a --></code>&lt;<code class="n"><!-- a href="" logicalPath="" -->Int<!-- /a --></code>&gt;</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In both cases, the variable <code class="code-voice">optionalInteger</code> is declared to have the type of an optional integer. Note that no whitespace may appear between the type and the <code class="code-voice">?</code>.</p><p class="para">The type <code class="code-voice">Optional&lt;Wrapped&gt;</code> is an enumeration with two cases, <code class="code-voice">None</code> and <code class="code-voice">Some(Wrapped)</code>, which are used to represent values that may or may not be present. Any type can be explicitly declared to be (or implicitly converted to) an optional type. If you don’t provide an initial value when you declare an optional variable or property, its value automatically defaults to <code class="code-voice">nil</code>.</p><p class="para">If an instance of an optional type contains a value, you can access that value using the postfix operator <code class="code-voice">!</code>, as shown below:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="vc">optionalInteger</code> = <code class="m">42</code></code></li>
            <li><code class="code-voice"><code class="vc">optionalInteger</code>! <code class="c">// 42</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Using the <code class="code-voice">!</code> operator to unwrap an optional that has a value of <code class="code-voice">nil</code> results in a runtime error.</p><p class="para">You can also use optional chaining and optional binding to conditionally perform an operation on an optional expression. If the value is <code class="code-voice">nil</code>, no operation is performed and therefore no runtime error is produced.</p><p class="para">For more information and to see examples that show how to use optional types, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH5-ID330" href="TheBasics.xhtml#TP40016643-CH5-ID330">Optionals</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an optional type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="optional-type">&#x200c;</a>
  <span class="syntax-def-name">
  optional-type
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">?</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID453">&#x200c;</a>
  <h3 class="section-name">Implicitly Unwrapped Optional Type</h3>
  <p class="para">The Swift language defines the postfix <code class="code-voice">!</code> as syntactic sugar for the named type <code class="code-voice">ImplicitlyUnwrappedOptional&lt;Wrapped&gt;</code>, which is defined in the Swift standard library. In other words, the following two declarations are equivalent:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">implicitlyUnwrappedString</code>: <code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>!</code></li>
            <li><code class="code-voice"><code class="kt">var</code> <code class="vc">implicitlyUnwrappedString</code>: <code class="n"><!-- a href="" logicalPath="" -->ImplicitlyUnwrappedOptional<!-- /a --></code>&lt;<code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>&gt;</code></li>
        </ol>
      </div>
  </div>
</section><p class="para">In both cases, the variable <code class="code-voice">implicitlyUnwrappedString</code> is declared to have the type of an implicitly unwrapped optional string. Note that no whitespace may appear between the type and the <code class="code-voice">!</code>.</p><p class="para">You can use implicitly unwrapped optionals in all the same places in your code that you can use optionals. For instance, you can assign values of implicitly unwrapped optionals to variables, constants, and properties of optionals, and vice versa.</p><p class="para">As with optionals, if you don’t provide an initial value when you declare an implicitly unwrapped optional variable or property, its value automatically defaults to <code class="code-voice">nil</code>.</p><p class="para">Because the value of an implicitly unwrapped optional is automatically unwrapped when you use it, there’s no need to use the <code class="code-voice">!</code> operator to unwrap it. That said, if you try to use an implicitly unwrapped optional that has a value of <code class="code-voice">nil</code>, you’ll get a runtime error.</p><p class="para">Use optional chaining to conditionally perform an operation on an implicitly unwrapped optional expression. If the value is <code class="code-voice">nil</code>, no operation is performed and therefore no runtime error is produced.</p><p class="para">For more information about implicitly unwrapped optional types, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH5-ID334" href="TheBasics.xhtml#TP40016643-CH5-ID334">Implicitly Unwrapped Optionals</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of an implicitly unwrapped optional type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="implicitly-unwrapped-optional-type">&#x200c;</a>
  <span class="syntax-def-name">
  implicitly-unwrapped-optional-type
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">!</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID454">&#x200c;</a>
  <h3 class="section-name">Protocol Composition Type</h3>
  <p class="para">A protocol composition type describes a type that conforms to each protocol in a list of specified protocols. Protocol composition types may be used in type annotations and in generic parameters.</p><p class="para">Protocol composition types have the following form:</p><span class="caption"></span>
<div class="code-outline">
  <ul class="code-outline-lines code-voice">
    <li><pre class="code-voice"><code class="kt">protocol</code>&lt;<em class="variable-text">Protocol 1</em>, <em class="variable-text">Protocol 2</em>&gt;</pre></li>
  </ul>
</div><p class="para">A protocol composition type allows you to specify a value whose type conforms to the requirements of multiple protocols without having to explicitly define a new, named protocol that inherits from each protocol you want the type to conform to. For example, specifying a protocol composition type <code class="code-voice">protocol&lt;ProtocolA, ProtocolB, ProtocolC&gt;</code> is effectively the same as defining a new protocol <code class="code-voice">ProtocolD</code> that inherits from <code class="code-voice">ProtocolA</code>, <code class="code-voice">ProtocolB</code>, and <code class="code-voice">ProtocolC</code>, but without having to introduce a new name.</p><p class="para">Each item in a protocol composition list must be either the name of protocol or a type alias of a protocol composition type. If the list is empty, it specifies the empty protocol composition type, which every type conforms to.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a protocol composition type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="protocol-composition-type">&#x200c;</a>
  <span class="syntax-def-name">
  protocol-composition-type
</span>
<span class="arrow">
  →
</span><code class="literal">protocol</code><code class="literal">&lt;</code><span class="optional"><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/protocol-identifier-list" href="Types.xhtml#protocol-identifier-list">protocol-identifier-list</a></span><sub class="subscript">opt</sub></span><code class="literal">&gt;</code>
</p><p class="syntax-def">
  <a id="protocol-identifier-list">&#x200c;</a>
  <span class="syntax-def-name">
  protocol-identifier-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/protocol-identifier" href="Types.xhtml#protocol-identifier">protocol-identifier</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/protocol-identifier" href="Types.xhtml#protocol-identifier">protocol-identifier</a></span><code class="literal">,</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/protocol-identifier-list" href="Types.xhtml#protocol-identifier-list">protocol-identifier-list</a></span>
</span>
</p><p class="syntax-def">
  <a id="protocol-identifier">&#x200c;</a>
  <span class="syntax-def-name">
  protocol-identifier
</span>
<span class="arrow">
  →
</span><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-identifier" href="Types.xhtml#type-identifier">type-identifier</a></span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID455">&#x200c;</a>
  <h3 class="section-name">Metatype Type</h3>
  <p class="para">A metatype type refers to the type of any type, including class types, structure types, enumeration types, and protocol types.</p><p class="para">The metatype of a class, structure, or enumeration type is the name of that type followed by <code class="code-voice">.Type</code>. The metatype of a protocol type—not the concrete type that conforms to the protocol at runtime—is the name of that protocol followed by <code class="code-voice">.Protocol</code>. For example, the metatype of the class type <code class="code-voice">SomeClass</code> is <code class="code-voice">SomeClass.Type</code> and the metatype of the protocol <code class="code-voice">SomeProtocol</code> is <code class="code-voice">SomeProtocol.Protocol</code>.</p><p class="para">You can use the postfix <code class="code-voice">self</code> expression to access a type as a value. For example, <code class="code-voice">SomeClass.self</code> returns <code class="code-voice">SomeClass</code> itself, not an instance of <code class="code-voice">SomeClass</code>. And <code class="code-voice">SomeProtocol.self</code> returns <code class="code-voice">SomeProtocol</code> itself, not an instance of a type that conforms to <code class="code-voice">SomeProtocol</code> at runtime. You can use a <code class="code-voice">dynamicType</code> expression with an instance of a type to access that instance’s dynamic, runtime type as a value, as the following example shows:</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">class</code> <code class="vc">SomeBaseClass</code> {</code></li>
            <li><code class="code-voice">    <code class="kt">class</code> <code class="kt">func</code> <code class="vc">printClassName</code>() {</code></li>
            <li><code class="code-voice">        <code class="vc">print</code>(<code class="s">&quot;SomeBaseClass&quot;</code>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="kt">class</code> <code class="vc">SomeSubClass</code>: <code class="n"><!-- a href="" logicalPath="" -->SomeBaseClass<!-- /a --></code> {</code></li>
            <li><code class="code-voice">    <code class="kt">override</code> <code class="kt">class</code> <code class="kt">func</code> <code class="vc">printClassName</code>() {</code></li>
            <li><code class="code-voice">        <code class="vc">print</code>(<code class="s">&quot;SomeSubClass&quot;</code>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">someInstance</code>: <code class="n"><!-- a href="" logicalPath="" -->SomeBaseClass<!-- /a --></code> = <code class="vc">SomeSubClass</code>()</code></li>
            <li><code class="code-voice"><code class="c">// The compile-time type of someInstance is SomeBaseClass,</code></code></li>
            <li><code class="code-voice"><code class="c">// and the runtime type of someInstance is SomeSubClass</code></code></li>
            <li><code class="code-voice"><code class="vc">someInstance</code>.<code class="kt">dynamicType</code>.<code class="vc">printClassName</code>()</code></li>
            <li><code class="code-voice"><code class="c">// Prints &quot;SomeSubClass&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Use the identity operators (<code class="code-voice">===</code> and <code class="code-voice">!==</code>) to test whether an instance’s runtime type is the same as its compile-time type.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">if</code> <code class="vc">someInstance</code>.<code class="kt">dynamicType</code> === <code class="vc">someInstance</code>.<code class="kt">self</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;The dynamic and static type of someInstance are the same&quot;</code>)</code></li>
            <li><code class="code-voice">} <code class="kt">else</code> {</code></li>
            <li><code class="code-voice">    <code class="vc">print</code>(<code class="s">&quot;The dynamic and static type of someInstance are different&quot;</code>)</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="c">// Prints &quot;The dynamic and static type of someInstance are different&quot;</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Use an initializer expression to construct an instance of a type from that type’s metatype value. For class instances, the initializer that’s called must be marked with the <code class="code-voice">required</code> keyword or the entire class marked with the <code class="code-voice">final</code> keyword.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">class</code> <code class="vc">AnotherSubClass</code>: <code class="n"><!-- a href="" logicalPath="" -->SomeBaseClass<!-- /a --></code> {</code></li>
            <li><code class="code-voice">    <code class="kt">let</code> <code class="vc">string</code>: <code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code></code></li>
            <li><code class="code-voice">    <code class="kt">required</code> <code class="kt">init</code>(<code class="vc">string</code>: <code class="n"><!-- a href="" logicalPath="" -->String<!-- /a --></code>) {</code></li>
            <li><code class="code-voice">        <code class="kt">self</code>.<code class="vc">string</code> = <code class="vc">string</code></code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">    <code class="kt">override</code> <code class="kt">class</code> <code class="kt">func</code> <code class="vc">printClassName</code>() {</code></li>
            <li><code class="code-voice">        <code class="vc">print</code>(<code class="s">&quot;AnotherSubClass&quot;</code>)</code></li>
            <li><code class="code-voice">    }</code></li>
            <li><code class="code-voice">}</code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">metatype</code>: <code class="n"><!-- a href="" logicalPath="" -->AnotherSubClass<!-- /a --></code>.<code class="vc">Type</code> = <code class="vc">AnotherSubClass</code>.<code class="kt">self</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">anotherInstance</code> = <code class="vc">metatype</code>.<code class="kt">init</code>(<code class="vc">string</code>: <code class="s">&quot;some string&quot;</code>)</code></li>
        </ol>
      </div>
  </div>
</section><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a metatype type
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="metatype-type">&#x200c;</a>
  <span class="syntax-def-name">
  metatype-type
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">.</code><code class="literal">Type</code>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type" href="Types.xhtml#type">type</a></span><code class="literal">.</code><code class="literal">Protocol</code>
</span>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID456">&#x200c;</a>
  <h3 class="section-name">Type Inheritance Clause</h3>
  <p class="para">A type inheritance clause is used to specify which class a named type inherits from and which protocols a named type conforms to. A type inheritance clause is also used to specify a <code class="code-voice">class</code> requirement on a protocol. A type inheritance clause begins with a colon (<code class="code-voice">:</code>), followed by either a <code class="code-voice">class</code> requirement, a list of type identifiers, or both.</p><p class="para">Class types can inherit from a single superclass and conform to any number of protocols. When defining a class, the name of the superclass must appear first in the list of type identifiers, followed by any number of protocols the class must conform to. If the class does not inherit from another class, the list can begin with a protocol instead. For an extended discussion and several examples of class inheritance, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH17-ID193" href="Inheritance.xhtml">Inheritance</a>.</p><p class="para">Other named types can only inherit from or conform to a list of protocols. Protocol types can inherit from any number of other protocols. When a protocol type inherits from other protocols, the set of requirements from those other protocols are aggregated together, and any type that inherits from the current protocol must conform to all of those requirements. As discussed in <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH34-ID369" href="Declarations.xhtml#TP40016643-CH34-ID369">Protocol Declaration</a>, you can include the <code class="code-voice">class</code> keyword as the first item in the type inheritance clause to mark a protocol declaration with a <code class="code-voice">class</code> requirement.</p><p class="para">A type inheritance clause in an enumeration definition can be either a list of protocols, or in the case of an enumeration that assigns raw values to its cases, a single, named type that specifies the type of those raw values. For an example of an enumeration definition that uses a type inheritance clause to specify the type of its raw values, see <a rel="me" data-id="//apple_ref/doc/uid/TP40016643-CH12-ID149" href="Enumerations.xhtml#TP40016643-CH12-ID149">Raw Values</a>.</p><div class="syntax-defs">
  <p class="syntax-defs-name">
  Grammar of a type inheritance clause
</p><div class="syntax-defs-group">
  <p class="syntax-def">
  <a id="type-inheritance-clause">&#x200c;</a>
  <span class="syntax-def-name">
  type-inheritance-clause
</span>
<span class="arrow">
  →
</span><code class="literal">:</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/class-requirement" href="Types.xhtml#class-requirement">class-requirement</a></span><code class="literal">,</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-inheritance-list" href="Types.xhtml#type-inheritance-list">type-inheritance-list</a></span>
</p><p class="syntax-def">
  <a id="TP40016643-CH31-NoLink_364">&#x200c;</a>
  <span class="syntax-def-name">
  type-inheritance-clause
</span>
<span class="arrow">
  →
</span><code class="literal">:</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/class-requirement" href="Types.xhtml#class-requirement">class-requirement</a></span>
</p><p class="syntax-def">
  <a id="TP40016643-CH31-NoLink_365">&#x200c;</a>
  <span class="syntax-def-name">
  type-inheritance-clause
</span>
<span class="arrow">
  →
</span><code class="literal">:</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-inheritance-list" href="Types.xhtml#type-inheritance-list">type-inheritance-list</a></span>
</p><p class="syntax-def">
  <a id="type-inheritance-list">&#x200c;</a>
  <span class="syntax-def-name">
  type-inheritance-list
</span>
<span class="arrow">
  →
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-identifier" href="Types.xhtml#type-identifier">type-identifier</a></span>
</span><span class="alternative">
  <span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-identifier" href="Types.xhtml#type-identifier">type-identifier</a></span><code class="literal">,</code><span class="syntactic-cat"><a rel="me" data-id="//apple_ref/swift/grammar/type-inheritance-list" href="Types.xhtml#type-inheritance-list">type-inheritance-list</a></span>
</span>
</p><p class="syntax-def">
  <a id="class-requirement">&#x200c;</a>
  <span class="syntax-def-name">
  class-requirement
</span>
<span class="arrow">
  →
</span><code class="literal">class</code>
</p>
</div>
 </div>
  
</section>
<section class="section">
	<a id="TP40016643-CH31-ID457">&#x200c;</a>
  <h3 class="section-name">Type Inference</h3>
  <p class="para">Swift uses type inference extensively, allowing you to omit the type or part of the type of many variables and expressions in your code. For example, instead of writing <code class="code-voice">var x: Int = 0</code>, you can write <code class="code-voice">var x = 0</code>, omitting the type completely—the compiler correctly infers that <code class="code-voice">x</code> names a value of type <code class="code-voice">Int</code>. Similarly, you can omit part of a type when the full type can be inferred from context. For instance, if you write <code class="code-voice">let dict: Dictionary = [&quot;A&quot;: 1]</code>, the compiler infers that <code class="code-voice">dict</code> has the type <code class="code-voice">Dictionary&lt;String, Int&gt;</code>.</p><p class="para">In both of the examples above, the type information is passed up from the leaves of the expression tree to its root. That is, the type of <code class="code-voice">x</code> in <code class="code-voice">var x: Int = 0</code> is inferred by first checking the type of <code class="code-voice">0</code> and then passing this type information up to the root (the variable <code class="code-voice">x</code>).</p><p class="para">In Swift, type information can also flow in the opposite direction—from the root down to the leaves. In the following example, for instance, the explicit type annotation (<code class="code-voice">: Float</code>) on the constant <code class="code-voice">eFloat</code> causes the numeric literal <code class="code-voice">2.71828</code> to have an inferred type of <code class="code-voice">Float</code> instead of <code class="code-voice">Double</code>.</p><section class="code-listing">
  
  <div class="code-sample">
      <div class="Swift">
        <ol class="code-lines">
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">e</code> = <code class="m">2.71828</code> <code class="c">// The type of e is inferred to be Double.</code></code></li>
            <li><code class="code-voice"><code class="kt">let</code> <code class="vc">eFloat</code>: <code class="n"><!-- a href="" logicalPath="" -->Float<!-- /a --></code> = <code class="m">2.71828</code> <code class="c">// The type of eFloat is Float.</code></code></li>
        </ol>
      </div>
  </div>
</section><p class="para">Type inference in Swift operates at the level of a single expression or statement. This means that all of the information needed to infer an omitted type or part of a type in an expression must be accessible from type-checking the expression or one of its subexpressions.</p>
  
</section>

  </article>
</div>

    </div>
  </body>
</html>
